<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link rel="preload" href="/_next/static/css/e94d3d602c719429.css" as="style"/><link rel="stylesheet" href="/_next/static/css/e94d3d602c719429.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-b84c169ac90f8974.js" defer=""></script><script src="/_next/static/chunks/framework-00b57966872fc495.js" defer=""></script><script src="/_next/static/chunks/main-1452d81522d66bc9.js" defer=""></script><script src="/_next/static/chunks/pages/_app-b0e469cf26f5278f.js" defer=""></script><script src="/_next/static/chunks/175675d1-a2f4b19cd9daa73f.js" defer=""></script><script src="/_next/static/chunks/980-0fae37084f488ec8.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-c00e23fa748dc7e0.js" defer=""></script><script src="/_next/static/DbfrYlt7puuYzlvH1AiOG/_buildManifest.js" defer=""></script><script src="/_next/static/DbfrYlt7puuYzlvH1AiOG/_ssgManifest.js" defer=""></script><script src="/_next/static/DbfrYlt7puuYzlvH1AiOG/_middlewareManifest.js" defer=""></script></head><body><div id="__next"><div class="flex flex-col min-h-screen"><header class="bg-sky-100 mb-8 py-4"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css" integrity="sha384-KiWOvVjnN8qwAZbuQyWDIbfCLFhLXNETzBQjA/92pIowpC0d2O3nppDGQVgwd2nB" crossorigin="anonymous"/><script defer="" src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js" integrity="sha384-0fdwu/T/EQMsQlrHCCHoH10pkPLlKA1jL5dFyUOvB3lfeT2540/2g6YgSi2BL14p" crossorigin="anonymous"></script><script defer="" src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/contrib/auto-render.min.js" integrity="sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR" crossorigin="anonymous"></script><div class="container mx-auto flex justify-center"><a href="/">Shariff Faleel</a></div></header><main class="container mx-auto flex-1"><div class="prose text-justify mx-auto max-w-screen-xl prose-img:block prose-img:m-auto prose-img:max-h-96 prose-p:w-full"><h1>PID with Haply</h1><div><p>For our third lab (or fourth?) in the CanHap course, we were asked to play with using PID to move the haply to a given position. With the haply, we can set the amount of torque to be applied and get the current position of the arms, which will help us calculate the position of the end-effector. Since we can directly set the position, the use of PID makes sense for this situation. We were given an implementation of the PID controls with a GUI configure the parameters of the PID controller. Initially, the coefficients of proportion (P), integral (I), and derivative (d) were set to zero and were instructed to try adjusting the P, I and D coefficients respectively (which is usually the order in which they are tuned) to understand how PID works.</p>
<p>All the code for this is on my <a href="https://github.com/ahmed-shariff/CanHap501_Lab_4.git">github</a>.</p>
<p>On a high level, the P component is primary component of the controller, which is basically the euclidean distance of the end-effector from the target location. The torque applied is proportional to this error (distance). The problem with using only this is that it tends to overshoot the target and results in the system oscillating around the target state. The I term is meant to reduce this oscillation. When the system is oscillating, this I term accumulates and torque proportional to this term is applied which eventually eliminates (or attenuates) the oscillation. Another problem that can occur with these systems is that large correction signals (distance or accumulated error) can throw the system into an unstable state. The D component is used to alleviate this. Basically, it dampens the signal at a rate proportional to the signal itself. This component can be further augmented by smoothing the dampening signal over the last few error signals (which I learned from the code itself).</p>
<p>So the idea of the lab is to see this in action. Right out the game, when I tried making even small adjustments to the P value, the whole systems starts to freak out. Playing around with the code and P5 library, what I wound up is adding a few additional outputs, a button and keybindings for convenience. I added a keybinding (&quot;z&quot; in my case) to reset the errors and PID coefficients to their respective initial values, and I added an output showing the values for the coefficients and the torque values being set. I wound up using these two alot to get a sense of what is going on and go through the lab task better. Every time the haply loses it's position, I'd hit &quot;z&quot; and then &quot;i&quot; (which resets the haply's position) then continue playing. Occasionally, the values are thrown into &quot;NaN&quot; values (which  I didn't put effort into fixing); other than that I was able to do everything quite smoothly (sans the haply's breakdowns). The following clip shows the changes I made to the UI.
<img src="/assets/2021-02-26/01_visualize_value.gif" alt="img"></p>
<p>Another trick I used for experimenting is to move the end-effector to the target and again hit &quot;z&quot; (reset coefficients and errors) after resetting the complete system (coefficients, errors, and haply's position). Then repeatedly hit &quot;b&quot;, moves the target to a different location and the haply is forced to move to that location.</p>
<h4>The P</h4>
<p>One of the first things I tried with the P values is to gradually increase the P and see how far I can push the end-effector without putting in too much effort. The following shows how far the end-effector moves as P is increased, starting from 0.</p>
<p><img src="/assets/2021-02-26/02_p.gif" alt="img"></p>
<p>When using only the P component, the haply tends to overshoot and loses it's position easily. On the rare occasion that it doesn't, it's not exactly on the target location. Which means the I and D components are necessary to arrive at a stable system.</p>
<p><img src="/assets/2021-02-26/04_p.gif" alt="img"></p>
<h4>The I</h4>
<p>I wanted to see how the I changed with time. I set P to 0, and adjusted I to see how it effects the force vector:</p>
<p><img src="/assets/2021-02-26/05_i_1.gif" alt="img"></p>
<p>Following that I tried moving the target points around to see how it behaves. It was much better than using only P, but still tends to overshoot and lose track of the haply's position.</p>
<p><img src="/assets/2021-02-26/05_i_2.gif" alt="img"></p>
<p>While it was fun to watch that, I found this behavior I though was interesting. Basically, the haply constrains my movements along the x-axis. What I basically had done is let the I accumulate over the y axis and set the smoothing to 99%. I don't entirely understand what causes that, but I thought it was something interesting.</p>
<p><img src="/assets/2021-02-26/03_i_wall.gif" alt="img"></p>
<h4>The D</h4>
<p>I tried different configuration and settled for the following ranges:</p>
<ul>
<li>P: 0.03 - 0.04</li>
<li>I: 5 - 6</li>
<li>D: 1.0 - 1.1</li>
<li>smoothing ~ 0.5</li>
</ul>
<p><img src="/assets/2021-02-26/06_d.gif" alt="img"></p>
<h4>Continuous PID</h4>
<p>To asses how the system behaves when following a path, I added a option to switch to having the target follow a circular path. And the end-effector is expected to follow the target.
<img src="/assets/2021-02-26/07_path.gif" alt="img"></p>
<p>When I hold back the end-effector, the force applied sensed increases gradually as the target moves away. Additionally, the D component drops to 0, as there is virtually no movement, and the I component accumulates quite a bit as I am holding it down for a bit. But the parameters were stable enough that when I let go it snaps back to following the path.</p>
<h4>Looptime</h4>
<p>When I increase the loop time the system tends to lose control more often. It was more preferable to have the looptime at a lower rate. When the looptime is set to anything above 1000, the haply's arms locks up whenever it reaches a point towards the outside edge of the device, causing the instability. Also, the lower frame-rates results in jerky motions as the PID has to accommodate a larger distance for each frame.</p>
<h4>Final thoughts</h4>
<p>Overall, it was fun to see the PID being applied to the haply to move it to a given location. And at the end of the day, the device is still in one piece, which is a win-win.</p>
</div><giscus-widget id="comments" repo="ahmed-shariff/ahmed-shariff.github.io" repoid="MDEwOlJlcG9zaXRvcnkxMjU3MDU3Nzc=" category="Announcements" categoryid="DIC_kwDOB34eMc4COpxh" mapping="pathname" reactionsenabled="1" emitmetadata="0" inputposition="top" theme="light" lang="en" loading="lazy"></giscus-widget></div></main><footer class="bg-sky-100 mt-8 py-4"><div class="container mx-auto flex justify-center text-sm">Â© 2022 Shariff Faleel</div></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"frontmatter":{"layout":"post","comments":true,"title":"PID with Haply","tags":["course","hci"],"tagline":"Playing with PID controllers and haply"},"content":"\r\nFor our third lab (or fourth?) in the CanHap course, we were asked to play with using PID to move the haply to a given position. With the haply, we can set the amount of torque to be applied and get the current position of the arms, which will help us calculate the position of the end-effector. Since we can directly set the position, the use of PID makes sense for this situation. We were given an implementation of the PID controls with a GUI configure the parameters of the PID controller. Initially, the coefficients of proportion (P), integral (I), and derivative (d) were set to zero and were instructed to try adjusting the P, I and D coefficients respectively (which is usually the order in which they are tuned) to understand how PID works.\r\n\r\nAll the code for this is on my [github](https://github.com/ahmed-shariff/CanHap501_Lab_4.git).\r\n\r\nOn a high level, the P component is primary component of the controller, which is basically the euclidean distance of the end-effector from the target location. The torque applied is proportional to this error (distance). The problem with using only this is that it tends to overshoot the target and results in the system oscillating around the target state. The I term is meant to reduce this oscillation. When the system is oscillating, this I term accumulates and torque proportional to this term is applied which eventually eliminates (or attenuates) the oscillation. Another problem that can occur with these systems is that large correction signals (distance or accumulated error) can throw the system into an unstable state. The D component is used to alleviate this. Basically, it dampens the signal at a rate proportional to the signal itself. This component can be further augmented by smoothing the dampening signal over the last few error signals (which I learned from the code itself).\r\n\r\n\r\nSo the idea of the lab is to see this in action. Right out the game, when I tried making even small adjustments to the P value, the whole systems starts to freak out. Playing around with the code and P5 library, what I wound up is adding a few additional outputs, a button and keybindings for convenience. I added a keybinding (\"z\" in my case) to reset the errors and PID coefficients to their respective initial values, and I added an output showing the values for the coefficients and the torque values being set. I wound up using these two alot to get a sense of what is going on and go through the lab task better. Every time the haply loses it's position, I'd hit \"z\" and then \"i\" (which resets the haply's position) then continue playing. Occasionally, the values are thrown into \"NaN\" values (which  I didn't put effort into fixing); other than that I was able to do everything quite smoothly (sans the haply's breakdowns). The following clip shows the changes I made to the UI.\r\n![img](/assets/2021-02-26/01_visualize_value.gif)\r\n\r\nAnother trick I used for experimenting is to move the end-effector to the target and again hit \"z\" (reset coefficients and errors) after resetting the complete system (coefficients, errors, and haply's position). Then repeatedly hit \"b\", moves the target to a different location and the haply is forced to move to that location.\r\n\r\n#### The P\r\nOne of the first things I tried with the P values is to gradually increase the P and see how far I can push the end-effector without putting in too much effort. The following shows how far the end-effector moves as P is increased, starting from 0.\r\n\r\n![img](/assets/2021-02-26/02_p.gif)\r\n\r\nWhen using only the P component, the haply tends to overshoot and loses it's position easily. On the rare occasion that it doesn't, it's not exactly on the target location. Which means the I and D components are necessary to arrive at a stable system.\r\n\r\n![img](/assets/2021-02-26/04_p.gif)\r\n\r\n#### The I\r\nI wanted to see how the I changed with time. I set P to 0, and adjusted I to see how it effects the force vector:\r\n\r\n![img](/assets/2021-02-26/05_i_1.gif)\r\n\r\nFollowing that I tried moving the target points around to see how it behaves. It was much better than using only P, but still tends to overshoot and lose track of the haply's position.\r\n\r\n![img](/assets/2021-02-26/05_i_2.gif)\r\n\r\nWhile it was fun to watch that, I found this behavior I though was interesting. Basically, the haply constrains my movements along the x-axis. What I basically had done is let the I accumulate over the y axis and set the smoothing to 99%. I don't entirely understand what causes that, but I thought it was something interesting.\r\n\r\n![img](/assets/2021-02-26/03_i_wall.gif)\r\n\r\n#### The D\r\n\r\nI tried different configuration and settled for the following ranges:\r\n- P: 0.03 - 0.04\r\n- I: 5 - 6\r\n- D: 1.0 - 1.1\r\n- smoothing ~ 0.5\r\n\r\n![img](/assets/2021-02-26/06_d.gif)\r\n\r\n#### Continuous PID\r\nTo asses how the system behaves when following a path, I added a option to switch to having the target follow a circular path. And the end-effector is expected to follow the target.\r\n![img](/assets/2021-02-26/07_path.gif)\r\n\r\nWhen I hold back the end-effector, the force applied sensed increases gradually as the target moves away. Additionally, the D component drops to 0, as there is virtually no movement, and the I component accumulates quite a bit as I am holding it down for a bit. But the parameters were stable enough that when I let go it snaps back to following the path.\r\n\r\n#### Looptime\r\nWhen I increase the loop time the system tends to lose control more often. It was more preferable to have the looptime at a lower rate. When the looptime is set to anything above 1000, the haply's arms locks up whenever it reaches a point towards the outside edge of the device, causing the instability. Also, the lower frame-rates results in jerky motions as the PID has to accommodate a larger distance for each frame.\r\n\r\n#### Final thoughts\r\nOverall, it was fun to see the PID being applied to the haply to move it to a given location. And at the end of the day, the device is still in one piece, which is a win-win.\r\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2021-02-26-canhap-lab4"},"buildId":"DbfrYlt7puuYzlvH1AiOG","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>