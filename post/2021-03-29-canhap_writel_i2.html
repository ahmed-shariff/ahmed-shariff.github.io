<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link rel="preload" href="/_next/static/css/6853c5fc042b5992.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6853c5fc042b5992.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-4de48dbd32378f56.js" defer=""></script><script src="/_next/static/chunks/framework-00b57966872fc495.js" defer=""></script><script src="/_next/static/chunks/main-1452d81522d66bc9.js" defer=""></script><script src="/_next/static/chunks/pages/_app-19620cb7a5c3b4e8.js" defer=""></script><script src="/_next/static/chunks/175675d1-a2f4b19cd9daa73f.js" defer=""></script><script src="/_next/static/chunks/706-5d4770c80855792c.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-e8e3457f1bacf2a2.js" defer=""></script><script src="/_next/static/tzuobdzOzF3WHvZRFh8g6/_buildManifest.js" defer=""></script><script src="/_next/static/tzuobdzOzF3WHvZRFh8g6/_ssgManifest.js" defer=""></script><script src="/_next/static/tzuobdzOzF3WHvZRFh8g6/_middlewareManifest.js" defer=""></script></head><body><div id="__next"><div class="flex flex-col min-h-screen bg-slate-700"><header class="bg-gray-800 mb-0 md:mb-8 py-1 text-gray-300 md:sticky top-0 left-0 right-0 drop-shadow-lg shadow-gray-900 z-10"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css" integrity="sha384-KiWOvVjnN8qwAZbuQyWDIbfCLFhLXNETzBQjA/92pIowpC0d2O3nppDGQVgwd2nB" crossorigin="anonymous"/><script defer="" src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js" integrity="sha384-0fdwu/T/EQMsQlrHCCHoH10pkPLlKA1jL5dFyUOvB3lfeT2540/2g6YgSi2BL14p" crossorigin="anonymous"></script><script defer="" src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/contrib/auto-render.min.js" integrity="sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR" crossorigin="anonymous"></script><div class="container mx-auto flex flex-col md:flex-row gap-x-12 items-center justify-center"><a class="transition duration-100 bg-transparent shadow-md shadow-transparent rounded-lg hover:shadow-gray-900 hover:bg-gray-700 hover:underline hover:decoration-2 px-4 py-2 items-center font-semibold text-lg" href="/">Shariff Faleel</a><a class="transition duration-100 bg-transparent shadow-md shadow-transparent rounded-lg hover:shadow-gray-900 hover:bg-gray-700 hover:underline hover:decoration-2 px-4 py-2 items-center undefined" href="/posts">Posts</a><a class="transition duration-100 bg-transparent shadow-md shadow-transparent rounded-lg hover:shadow-gray-900 hover:bg-gray-700 hover:underline hover:decoration-2 px-4 py-2 items-center undefined" href="/posts?pub=true">Publications</a><a class="transition duration-100 bg-transparent shadow-md shadow-transparent rounded-lg hover:shadow-gray-900 hover:bg-gray-700 hover:underline hover:decoration-2 px-4 py-2 items-center group" href="/"><div>Quick links<!-- --><svg fill="currentColor" viewBox="0 0 20 20" class="inline w-4 h-4 mt-1 ml-1 transition-transform duration-200 transform md:-mt-1 rotate-0 group-hover:rotate-180"><path fill-rule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg></div><div class="absolute w-full mt-2 origin-top-right rounded-md shadow-lg w-fit transition-transform transition-opacity ease-in-out duration-200 opacity-0 scale-0 group-hover:opacity-100 group-hover:scale-100"><div class="p-2 bg-gray-700 rounded-md shadow dark-mode:bg-gray-700"><div class="block px-4 py-2 rounded-lg hover:bg-gray-600 hover:underline hover:decoration-2 items-center justify-left flex flex-row space-x-2" href="https://gist.github.com/ahmed-shariff"> <!-- --><div><svg stroke="currentColor" fill="currentColor" stroke-width="0" role="img" viewBox="0 0 24 24" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><title></title><path d="M12 .297c-6.63 0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577 0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93 0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176 0 0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22 0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22 0 1.606-.015 2.896-.015 3.286 0 .315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12"></path></svg></div><div>github-gists</div></div><div class="block px-4 py-2 rounded-lg hover:bg-gray-600 hover:underline hover:decoration-2 items-center justify-left flex flex-row space-x-2" href="/posts.xml"> <!-- --><div><svg stroke="currentColor" fill="currentColor" stroke-width="0" role="img" viewBox="0 0 24 24" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><title></title><path d="M19.199 24C19.199 13.467 10.533 4.8 0 4.8V0c13.165 0 24 10.835 24 24h-4.801zM3.291 17.415c1.814 0 3.293 1.479 3.293 3.295 0 1.813-1.485 3.29-3.301 3.29C1.47 24 0 22.526 0 20.71s1.475-3.294 3.291-3.295zM15.909 24h-4.665c0-6.169-5.075-11.245-11.244-11.245V8.09c8.727 0 15.909 7.184 15.909 15.91z"></path></svg></div><div>RSS feed</div></div></div></div></a></div></header><main class="container mx-auto flex-1"><div class="p-5 md:p-0 prose dark:prose-invert text-justify mx-auto max-w-screen-xl prose-img:block prose-img:m-auto prose-img:max-h-96 prose-p:w-full"><div class="text-xs text-slate-400">March 29, 2021<!-- --><div class="undefined flex gap-x-1 flex-wrap"><a class="text-gray-400" href="/posts?tags=course">#course</a><a class="text-gray-400" href="/posts?tags=hci">#hci</a></div></div><h1 class="text-left">Writely (Part 2) - Face the kraken<!-- --></h1><div><h3>Recap from <a href="2021-03-08-canhap_writely_i1">iteration 1</a>:</h3>
<p>Our goal was to train the non-dominant hand to write items. In the first iteration we had tried to narrow down what could be done for this project and identify the types of feedback we would want to render to the user, which were:</p>
<ol>
<li>Partial feedback: Where the participants would receive a force feedback when they veer off too much from their path.</li>
<li>Full feedback: Where the user is guided throughout the writing process.</li>
<li>Anti-guiding: In this method, the system actively forces the user off the path the user is expected to follow.</li>
<li>Disturbance: Here the user is provided a random nudge now and then.</li>
</ol>
<p>Consequently we had set out to build a foundational platform and the gather the necessary tools. Primarily, we built a <a href="https://bradleyrrr.github.io/sample/pi1.html#haply-modifications">3D printed pen effector</a> the <a href="2021-03-08-canhap_writely_i1">UI component, tested out a pressure sensor</a> and did some preliminary exploration on <a href="https://joshibibhushan.medium.com/writely-iteration-1-438068380fcc#4077">how to actually &quot;write&quot; using the haply</a>.</p>
<h3>The Kraken</h3>
<p>The goal of this iteration implement and test the different haptic feedback mechanisms. The biggest challenges were around two components. First, was around calculating how &quot;correct&quot; the current position of the user is. If it is just inside-the-letter-or-outside it would be pretty straightforward. But the way we had conceptualized this system, we need to know &quot;how much&quot; inside-the-letter-or-outside we are. The second was about how to render the force. I am going to start by talking about how we tackled the force rendering problem. Then discuss how the positions were calculated and wrap up with how we render the haptic feedbacks.</p>
<h4>Rendering the force</h4>
<p>Initially we thought we'd need the force calculation we had used for the <a href="2021-02-26-canhap-lab4">PID lab</a>. We started by trying to set the values for the P, I and D to do what we wanted. It was only later we had realized that fisca (which we used in <a href="2021-02-05-canhap-lab2">lab 2</a> and then in <a href="2021-03-12-canhap-lab3">lab 3</a>) also basically uses a PID system internally to address the issue of positioning the end effector of the haply. After playing around with the library, to use the positioning functions used by fisca and also add an additional force, we simply had to manipulate the force fisca's physics engine calculates before rending it into haply. This also helped with my lab 3 submission, where I used fisca to render different types of haptic feedback to <a href="2021-03-12-canhap-lab3">convey a &quot;word&quot;</a>. So we wound up completely stripping the PID code and refactoring the system to use fisca.</p>
<h4>Position calculations</h4>
<p>Bibushan had done a pretty cool implementation of using the font files itself to generate the letters in the form of a <code>FPoly</code>. <code>FPloy</code> is one of the classes from fisca, so having the fonts as <code>FPoly</code> objects allows us to connect it with fisca. The following figure demonstrates this system which uses the <code>geommetric</code> library to generate the letters.</p>
<p><img src="/assets/2021-03-29/01_fonts.gif" alt="01"></p>
<p>This method basically uses the outer vertices defined by the font to draw object. All except the disturbance feedback required knowing the center of the letter, i.e, the inner vertices. For the initial iteration, I tried moving horizontally and vertically from the position of the end effector on the screen and picking the closest edges on the screen (in this case, simply check for a change in color). And if I am inside the letter, which we can get using fisca's <code>isTouching</code> method. Following that, the idea was to calculate the closest edge and then get the edge on the opposite vector. The following shows the edge of the font being picked being marked by a red circle.</p>
<p><img src="/assets/2021-03-29/02_vh_border.gif" alt="02"></p>
<p>Two problems stood out which blocked us from proceeding. First, this method is not always reliable, specially when considering letters that have anything other than vertical or horizontal lines. Checking diagonals also could have improved the approximation of the edge. But, the second issue was the showstopper: getting this method to work with letter that have &quot;junctions&quot;, think the letter &quot;T&quot;. Once, we realized it would be tricky to solve this problem, we went back to the drawing board.</p>
<p>Building off Bibushans <code>Alphabets</code> system, I resorted to using the inner vertices for the font, and draw lines with a given thickness to render fonts. Which turned out to be a simpler solution, with a few caveats: First, the inner vertices cannot be drawn from the font files, which means we have to manually calculate and specify the vertices. Second, drawing smooth rounded lines is not possible. But this approaches allowed us to get started on trying out the haptic feedback, so we are using this approach for now. The following image demonstrates the basic idea.</p>
<p><img src="/assets/2021-03-29/03_graph.png" alt="03"></p>
<p>The points provided would be P1, P2 and P3. As shown, using fisca's <code>FLine</code> lines are drawn with a certain thickness. Then to calculate the position the end effector (EE), project the position EE on the extended line of each line segment (blue arrows). Then get the line segment which is closest and also the projection calls inside the line segment. For example, in the above diagram, the EE falls outside the P2 to P3 line segment. Hence will not be used. Hence the problem of guiding or anti-guiding becomes rendering a force proportional to the distance from the EE to the projection on the line segment.</p>
<h3>The haptic feedback</h3>
<p>Through this implementation, we were not able to clearly establish what partial feedback is. Hence for now, we are not considering the partial feedback. The other feedbacks are calculated as follows: For disturbance, Bradely tackled this one and also attempted a mini user study to understand what properties work best. The idea was to randomly generate a force in a random direction.</p>
<p>With the other two, as described in the previous section, we render a force proportional to distance to the closes line segment. We realized having this feedback while outside of the letter (i.e not in touch with the line segment) was not very useful or comfortable. Hence we restricted the force rendering only when the EE is touching any of the <code>FLine</code>s representing the line segments. Another issue we ran into was that when the user first touches the letter with the EE, the force rendered immediately can be too much it completely force the user off the letter. Dampeining didn't help much here. Hence, to avoid this we used a ramping function to ease in the force being rendered. To further smoothen  the force we , we used theFor guidance, it was force proportional to distance vector (blue arrows), and for the anti-guidance it was inversely proportional. The following demos show drawing on a random shape with visualizations of the force being rendered, the closest point picked up on the line, and the drawn letter. (ps: the force lines shown in the below diagram are in the direction of the vector calculated (blue arrrow in above diagram) and not the force itself)</p>
<p>For guiding, I am starting with showing the force being rendered when moving away from the center of the line segment. Then draw around by deliberately trying to go off the path:
<img src="/assets/2021-03-29/04_full_guiding.gif" alt="04"></p>
<p>For anti-guiding:
<img src="/assets/2021-03-29/05_anti_guiding.gif" alt="05"></p>
<h3>Reflections</h3>
<p>As someone used to solving problem with code, it was interesting to see how hardware plays into this. Since the haply's &quot;mood&quot; plays a huge part in this system, relying just on code solution didn't work for us; as a result we had to try different approaches, particularly with calculating the relevant vector values. Naturally, I immensely enjoyed solving the different math and programming problems, figuring out to work with the hardware was much appreciated icing on the cake.</p>
<p>Another interesting observation that came about was with the different haptic feedback. The full guidance seems to take effort off of me, whereas the anti-guidance requires me to pt in more effort into the process to &quot;write&quot; properly. I was not expecting these different approaches to have such a distinct feeling from one another. I still haven't had the chance to watch someone else experience this. Which one would result in a training out motor skills would be the bulk of our third iteration. Bradely had already formulated a questionnaire and a study design, we'll be working off that to further tweak the system to identify which feedback mechanism works best.</p>
<p>Not to mention, we still have a few bugs and technical issues that needs solving (eg. the jittering in the anti-guidance approach). Overall, this has been a pleasant learning experience and I am looking forward to the final iteration of this project.</p>
</div><div class="m-4 border-t-4 border-slate-400/25"></div><giscus-widget id="comments" repo="ahmed-shariff/ahmed-shariff.github.io" repoid="MDEwOlJlcG9zaXRvcnkxMjU3MDU3Nzc=" category="Announcements" categoryid="DIC_kwDOB34eMc4COpxh" mapping="pathname" reactionsenabled="1" emitmetadata="0" inputposition="top" theme="light" lang="en" loading="lazy"></giscus-widget></div></main><div class="fixed bottom-4 right-4 drop-shadow-lg z-50 shadow-gray-900"><button><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 512 512" class="fill-sky-400 fill-gray-900 rounded-full bg-slate-600 hover:bg-slate-500" height="60" width="60" xmlns="http://www.w3.org/2000/svg"><path d="M256 464c114.9 0 208-93.1 208-208S370.9 48 256 48 48 141.1 48 256s93.1 208 208 208zm0-244.5l-81.1 81.9c-7.5 7.5-19.8 7.5-27.3 0s-7.5-19.8 0-27.3l95.7-95.4c7.3-7.3 19.1-7.5 26.6-.6l94.3 94c3.8 3.8 5.7 8.7 5.7 13.7 0 4.9-1.9 9.9-5.6 13.6-7.5 7.5-19.7 7.6-27.3 0l-81-79.9z"></path></svg></button></div><footer class="bg-gray-800 mt-8 py-4 text-gray-300 drop-shadow-lg shadow-gray-900"><div class="container mx-auto flex justify-center text-sm">© 2022 Shariff Faleel</div></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"slug":"2021-03-29-canhap_writel_i2","frontmatter":{"layout":"post","comments":true,"title":"Writely (Part 2) - Face the kraken","tags":["course","hci"],"tagline":"Second iteration of the canhap project, where wrestle the haptic implementations on our system."},"content":"\n### Recap from [iteration 1]({{ site.baseurl }}{% post_url 2021-03-08-canhap_writely_i1 %}):\n\nOur goal was to train the non-dominant hand to write items. In the first iteration we had tried to narrow down what could be done for this project and identify the types of feedback we would want to render to the user, which were:\n1. Partial feedback: Where the participants would receive a force feedback when they veer off too much from their path.\n2. Full feedback: Where the user is guided throughout the writing process.\n3. Anti-guiding: In this method, the system actively forces the user off the path the user is expected to follow.\n4. Disturbance: Here the user is provided a random nudge now and then.\n\nConsequently we had set out to build a foundational platform and the gather the necessary tools. Primarily, we built a [3D printed pen effector](https://bradleyrrr.github.io/sample/pi1.html#haply-modifications) the [UI component, tested out a pressure sensor]({{ site.baseurl }}{% post_url 2021-03-08-canhap_writely_i1 %}) and did some preliminary exploration on [how to actually \"write\" using the haply](https://joshibibhushan.medium.com/writely-iteration-1-438068380fcc#4077).\n\n### The Kraken\n\nThe goal of this iteration implement and test the different haptic feedback mechanisms. The biggest challenges were around two components. First, was around calculating how \"correct\" the current position of the user is. If it is just inside-the-letter-or-outside it would be pretty straightforward. But the way we had conceptualized this system, we need to know \"how much\" inside-the-letter-or-outside we are. The second was about how to render the force. I am going to start by talking about how we tackled the force rendering problem. Then discuss how the positions were calculated and wrap up with how we render the haptic feedbacks.\n\n#### Rendering the force\n\nInitially we thought we'd need the force calculation we had used for the [PID lab]({{ site.baseurl }}{% post_url 2021-02-26-canhap-lab4 %}). We started by trying to set the values for the P, I and D to do what we wanted. It was only later we had realized that fisca (which we used in [lab 2]({{ site.baseurl }}{% post_url 2021-02-05-canhap-lab2 %}) and then in [lab 3]({{ site.baseurl }}{% post_url 2021-03-12-canhap-lab3 %})) also basically uses a PID system internally to address the issue of positioning the end effector of the haply. After playing around with the library, to use the positioning functions used by fisca and also add an additional force, we simply had to manipulate the force fisca's physics engine calculates before rending it into haply. This also helped with my lab 3 submission, where I used fisca to render different types of haptic feedback to [convey a \"word\"]({{ site.baseurl }}{% post_url 2021-03-12-canhap-lab3 %}). So we wound up completely stripping the PID code and refactoring the system to use fisca. \n\n#### Position calculations\n\nBibushan had done a pretty cool implementation of using the font files itself to generate the letters in the form of a `FPoly`. `FPloy` is one of the classes from fisca, so having the fonts as `FPoly` objects allows us to connect it with fisca. The following figure demonstrates this system which uses the `geommetric` library to generate the letters.\n\n![01](/assets/2021-03-29/01_fonts.gif)\n\nThis method basically uses the outer vertices defined by the font to draw object. All except the disturbance feedback required knowing the center of the letter, i.e, the inner vertices. For the initial iteration, I tried moving horizontally and vertically from the position of the end effector on the screen and picking the closest edges on the screen (in this case, simply check for a change in color). And if I am inside the letter, which we can get using fisca's `isTouching` method. Following that, the idea was to calculate the closest edge and then get the edge on the opposite vector. The following shows the edge of the font being picked being marked by a red circle.\n\n![02](/assets/2021-03-29/02_vh_border.gif)\n\nTwo problems stood out which blocked us from proceeding. First, this method is not always reliable, specially when considering letters that have anything other than vertical or horizontal lines. Checking diagonals also could have improved the approximation of the edge. But, the second issue was the showstopper: getting this method to work with letter that have \"junctions\", think the letter \"T\". Once, we realized it would be tricky to solve this problem, we went back to the drawing board. \n\nBuilding off Bibushans `Alphabets` system, I resorted to using the inner vertices for the font, and draw lines with a given thickness to render fonts. Which turned out to be a simpler solution, with a few caveats: First, the inner vertices cannot be drawn from the font files, which means we have to manually calculate and specify the vertices. Second, drawing smooth rounded lines is not possible. But this approaches allowed us to get started on trying out the haptic feedback, so we are using this approach for now. The following image demonstrates the basic idea.\n\n![03](/assets/2021-03-29/03_graph.png)\n\nThe points provided would be P1, P2 and P3. As shown, using fisca's `FLine` lines are drawn with a certain thickness. Then to calculate the position the end effector (EE), project the position EE on the extended line of each line segment (blue arrows). Then get the line segment which is closest and also the projection calls inside the line segment. For example, in the above diagram, the EE falls outside the P2 to P3 line segment. Hence will not be used. Hence the problem of guiding or anti-guiding becomes rendering a force proportional to the distance from the EE to the projection on the line segment.\n\n### The haptic feedback\n\nThrough this implementation, we were not able to clearly establish what partial feedback is. Hence for now, we are not considering the partial feedback. The other feedbacks are calculated as follows: For disturbance, Bradely tackled this one and also attempted a mini user study to understand what properties work best. The idea was to randomly generate a force in a random direction.\n\nWith the other two, as described in the previous section, we render a force proportional to distance to the closes line segment. We realized having this feedback while outside of the letter (i.e not in touch with the line segment) was not very useful or comfortable. Hence we restricted the force rendering only when the EE is touching any of the `FLine`s representing the line segments. Another issue we ran into was that when the user first touches the letter with the EE, the force rendered immediately can be too much it completely force the user off the letter. Dampeining didn't help much here. Hence, to avoid this we used a ramping function to ease in the force being rendered. To further smoothen  the force we , we used theFor guidance, it was force proportional to distance vector (blue arrows), and for the anti-guidance it was inversely proportional. The following demos show drawing on a random shape with visualizations of the force being rendered, the closest point picked up on the line, and the drawn letter. (ps: the force lines shown in the below diagram are in the direction of the vector calculated (blue arrrow in above diagram) and not the force itself)\n\nFor guiding, I am starting with showing the force being rendered when moving away from the center of the line segment. Then draw around by deliberately trying to go off the path:\n![04](/assets/2021-03-29/04_full_guiding.gif)\n\nFor anti-guiding:\n![05](/assets/2021-03-29/05_anti_guiding.gif)\n\n### Reflections\n\nAs someone used to solving problem with code, it was interesting to see how hardware plays into this. Since the haply's \"mood\" plays a huge part in this system, relying just on code solution didn't work for us; as a result we had to try different approaches, particularly with calculating the relevant vector values. Naturally, I immensely enjoyed solving the different math and programming problems, figuring out to work with the hardware was much appreciated icing on the cake.\n\nAnother interesting observation that came about was with the different haptic feedback. The full guidance seems to take effort off of me, whereas the anti-guidance requires me to pt in more effort into the process to \"write\" properly. I was not expecting these different approaches to have such a distinct feeling from one another. I still haven't had the chance to watch someone else experience this. Which one would result in a training out motor skills would be the bulk of our third iteration. Bradely had already formulated a questionnaire and a study design, we'll be working off that to further tweak the system to identify which feedback mechanism works best.\n\nNot to mention, we still have a few bugs and technical issues that needs solving (eg. the jittering in the anti-guidance approach). Overall, this has been a pleasant learning experience and I am looking forward to the final iteration of this project.\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2021-03-29-canhap_writel_i2"},"buildId":"tzuobdzOzF3WHvZRFh8g6","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>