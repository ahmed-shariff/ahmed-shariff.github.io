---
layout: post
comments: true
title: PID with Haply
tags: ["course", "hci"]
tagline: Playing with PID controllers and haply
---

For our third lab (or fourth?) in the CanHap course, we were asked to play with using PID to move the haply to a given position. With the haply, we can set the amount of torque to be applied and get the current position of the arms, which will help us calculate the position of the end-effector. Since we can directly set the position, the use of PID makes sense for this situation. We were given an implementation of the PID controls with a GUI configure the parameters of the PID controller. Initially, the coefficients of proportion (P), integral (I), and derivative (d) were set to zero and were instructed to try adjusting the P, I and D coefficients respectively (which is usually the order in which they are tuned) to understand how PID works.

All the code for this is on my [github](https://github.com/ahmed-shariff/CanHap501_Lab_4.git).

On a high level, the P component is primary component of the controller, which is basically the euclidean distance of the end-effector from the target location. The torque applied is proportional to this error (distance). The problem with using only this is that it tends to overshoot the target and results in the system oscillating around the target state. The I term is meant to reduce this oscillation. When the system is oscillating, this I term accumulates and torque proportional to this term is applied which eventually eliminates (or attenuates) the oscillation. Another problem that can occur with these systems is that large correction signals (distance or accumulated error) can throw the system into an unstable state. The D component is used to alleviate this. Basically, it dampens the signal at a rate proportional to the signal itself. This component can be further augmented by smoothing the dampening signal over the last few error signals (which I learned from the code itself).


So the idea of the lab is to see this in action. Right out the game, when I tried making even small adjustments to the P value, the whole systems starts to freak out. Playing around with the code and P5 library, what I wound up is adding a few additional outputs, a button and keybindings for convenience. I added a keybinding ("z" in my case) to reset the errors and PID coefficients to their respective initial values, and I added an output showing the values for the coefficients and the torque values being set. I wound up using these two alot to get a sense of what is going on and go through the lab task better. Every time the haply loses it's position, I'd hit "z" and then "i" (which resets the haply's position) then continue playing. Occasionally, the values are thrown into "NaN" values (which  I didn't put effort into fixing); other than that I was able to do everything quite smoothly (sans the haply's breakdowns). The following clip shows the changes I made to the UI.
![img](/public/assets/2021-02-26/01_visualize_value.gif)

Another trick I used for experimenting is to move the end-effector to the target and again hit "z" (reset coefficients and errors) after resetting the complete system (coefficients, errors, and haply's position). Then repeatedly hit "b", moves the target to a different location and the haply is forced to move to that location.

#### The P
One of the first things I tried with the P values is to gradually increase the P and see how far I can push the end-effector without putting in too much effort. The following shows how far the end-effector moves as P is increased, starting from 0.

![img](/public/assets/2021-02-26/02_p.gif)

When using only the P component, the haply tends to overshoot and loses it's position easily. On the rare occasion that it doesn't, it's not exactly on the target location. Which means the I and D components are necessary to arrive at a stable system.

![img](/public/assets/2021-02-26/04_p.gif)


