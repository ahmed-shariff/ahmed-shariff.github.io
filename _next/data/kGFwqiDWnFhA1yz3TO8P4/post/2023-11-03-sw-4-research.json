{"pageProps":{"slug":"2023-11-03-sw-4-research","frontmatter":{"layout":"post","comments":true,"title":"Software development for research projects","tags":["programming","hci","machine learning"],"tagline":"My current approach to writing software artifacts in research projects."},"content":"\nLast week, at the [OVI lab's](https://ovi.ok.ubc.ca) weekly meeting, I presented my approach to writing software artifacts for research projects. The slides are as follows:\n\n<iframe src=\"https://docs.google.com/presentation/d/e/2PACX-1vQOGJDiY6Cqv7X7V9zSrrJh8CwMEVlHmlAZLX8ZUixo4PLwqI5kH8GSAtFQpP0Pcmi1-fuagcqAt58L/embed?start=false&loop=false&delayms=3000\" frameborder=\"0\" width=\"960\" height=\"569\" allowfullscreen=\"true\" mozallowfullscreen=\"true\" webkitallowfullscreen=\"true\"></iframe>\n\nIn this blog post, I am going to elaborate and expand on the presentation (mostly for my own reference).\n\nPretty much always the software artifacts in research projects are not something that are carefully planned and thought out.\nIt usually starts with something like \"This is a cool idea, let's quickly cook something up and see if it has any substance\".\nIf it does pan out, then do a little bit more to see if it is worth further exploring.\nAlong the way, a whole array of problems show up and you add patches to solve them.\nMore often than not, you end have having to completely pivot, for a million different reasons, which makes the code base look a lot nicer.\nWhen you reach a point where it can be used to start running experiments and collecting data, you add a few more things to be able to do that.\nWhat ends up happening is the interesting ideas/tools get buried inside all the explorations, configurations, checks and balances you added along the way.\nIf you want to extract the useful components, ideas or tools, either to distribute them as packages others could use or even for you to use in projects down the line, you end up having to do a MOJOR refactor, which is never ever fun.\n\nWhat I am going to talk about in this article is how I approach any software development for research projects so that the artifacts are more maintainable while also adding as little overhead to the research process as possible.\n\nAs described above most software components in research projects do the following: Given a set of configurations/parameters, do something and then collect data.\nFor example, If you are doing a machine learning project, you provide parameters that would configure, train and test the models. \nYou may have multiple different configurations, implementations, etc.\nThen you collect and compare the results.\nAnother example: You are running a user study comparing two different interaction techniques.\nBased on some criteria, for each participant you administer conditions where they do something with the interaction techniques then you collect data from it and analyze it.\nFrom what I have seen so far, this pattern applies to the vast majority of the research projects.\n\n![basic pipeline](/assets/2023-11-03/basic-pipeline.jpg) \n\nFor any given research project, it is the \"doing something\" part that is of interest.\nIn fact, numerous tools out there do the \"configure & setup\" and \"record data\".\nGiven my background in ML and HCI, I have worked with MLOps tools like [mlflow](https://mlflow.org) (which can be used for user studies as well, that's probably another article) and [UXF in Unity](https://github.com/immersivecognition/unity-experiment-framework).\nMy colleagues who work on brain-computer interfaces use tools like [OpenViBE](http://openvibe.inria.fr).\nMost of these tools combine both the \"configure & setup\" and \"record data\" pieces. \nSo I am going to combine them into one component - the \"other stuff\".\nThere is one \"gotcha\" with these tools that I'll come back to later in the article.\n\n![Basic pipeline, combined other stuff](/assets/2023-11-03/basic-pipeline2.jpg)\n\nWhen I set up any project to start exploring an idea, I set it up such that it would/could be a package.\nThere is something to be said about experimenting on a throwaway project and starting over once you get a hang of it, but that's another conversation altogether.\nWhatever functionality I am implementing, I approach it like developing a tool.\nThe core functionality is written as function(s)/class(s).\nThis core would take in parameters or configurations and have hooks & events in places I might want to get data from.\nDepending on what it is I also would wrap it and provide other interfaces to it, like a REST API or a CLI.\nThese wrappers are thin layers you can set up with very little effort.\n\n![Core functionality](/assets/2023-11-03/core-functionality.jpg)\n\nWhat this allows me to do is, import it anywhere I want and use it.\nIt can be in an experiment or a different project which uses this as a feature.\nAlso, when I want to demo/test it, I can spin it up without having to deal with all the overhead that comes with the experiment-related code.\n\nComing back to the science, when running experiments, I would have a simple setup that configures the \"core functionality\" using one of the given interfaces, and also add hooks anywhere I need to record data.\n\n![Core functionality and study implementation](/assets/2023-11-03/core-functionality-and-study.jpg)\n\nThis most likely would be wrapped in the whichever \"other stuff\" I am using.\n\nI mentioned a \"gotcha\" with the \"other stuff\": Sometimes, you want to be able to manage the flow of the study without having to re-run the whole thing.\nWith ML projects you could ctrl+c and use the last checkpoint (or something like that) to test.\nBut this is not a good option when you are running user studies. \nYou want the study to proceed with minimal input to avoid human errors.\nBut you also want to have control of the flow in the off-chance something goes wrong.\nI've seen different people use different solutions to that.\nI had written a Python package for that - experiment-server (<https://github.com/ahmed-shariff/experiment_server>) and an associated UXF extension to use it with Unity projects (<https://github.com/ovi-lab/UXF-extensions>).\nThat would be the red part on the \"other stuff\" in the figure below.\nThe study implementation would query the experiment-server to get the configuration information to load before each block.\nThis lets the study progress without input, but when necessary, I can step in and control the flow if needed.\n\n![full pipeline](/assets/2023-11-03/full-setup.jpg)\n\nMost of what I am talking about here will not be much of a surprise for anyone with a software engineering background.\nBut once you start to dig in, even with the SE experience, you tend to miss stuff.\n\nAs of writing this article, this is how I am approaching projects.\nAs with anything else, it's always evolving.\n\n"},"__N_SSG":true}